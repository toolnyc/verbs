---
import type { Mix } from '../../lib/supabase';

interface Props {
  mixes: Mix[];
}

const { mixes } = Astro.props;
const firstMix = mixes[0];
---

{mixes.length > 0 && (
  <div class="persistent-player" id="persistentPlayer" data-mixes={JSON.stringify(mixes)}>
    <audio id="globalAudio" transition:persist="audio"></audio>

    <div class="player-bar">
      <div class="player-controls">
        <button class="player-btn player-prev" aria-label="Previous">Prev</button>
        <button class="player-btn player-play" aria-label="Play">
          <span class="play-text">Play</span>
          <span class="pause-text">Pause</span>
        </button>
        <button class="player-btn player-next" aria-label="Next">Next</button>
      </div>

      <div class="player-marquee">
        <div class="marquee-track">
          <span class="marquee-content">
            <span class="now-playing">Now playing:</span>
            <span class="player-title">{firstMix.title}</span>
            <span class="player-time">0:00</span>
          </span>
          <span class="marquee-content" aria-hidden="true">
            <span class="now-playing">Now playing:</span>
            <span class="player-title">{firstMix.title}</span>
            <span class="player-time">0:00</span>
          </span>
        </div>
      </div>

      <div class="player-progress-wrap">
        <div class="player-progress-bar">
          <div class="player-progress-fill"></div>
        </div>
      </div>
    </div>
  </div>
)}

<style>
  .persistent-player {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    background: var(--color-fg);
    color: var(--color-bg);
  }

  .player-bar {
    display: flex;
    align-items: center;
    height: 44px;
    padding: 0 var(--space-md);
    gap: var(--space-lg);
  }

  .player-controls {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    flex-shrink: 0;
  }

  .player-btn {
    background: transparent;
    border: 1px solid currentColor;
    color: inherit;
    padding: var(--space-xs) var(--space-sm);
    font-size: var(--text-xs);
    cursor: pointer;
    transition: background 0.15s, color 0.15s;
    white-space: nowrap;
  }

  .player-btn:hover {
    background: var(--color-bg);
    color: var(--color-fg);
  }

  .player-play {
    background: var(--color-blue);
    border-color: var(--color-blue);
  }

  .player-play:hover {
    background: transparent;
    color: var(--color-blue);
  }

  .player-play .pause-text {
    display: none;
  }

  .persistent-player.playing .player-play .play-text {
    display: none;
  }

  .persistent-player.playing .player-play .pause-text {
    display: inline;
  }

  /* Marquee container */
  .player-marquee {
    flex: 1;
    overflow: hidden;
    mask-image: linear-gradient(to right, transparent, black 5%, black 95%, transparent);
    -webkit-mask-image: linear-gradient(to right, transparent, black 5%, black 95%, transparent);
  }

  .marquee-track {
    display: flex;
    width: max-content;
    animation: marquee 20s linear infinite;
    animation-play-state: paused;
  }

  .persistent-player.playing .marquee-track {
    animation-play-state: running;
  }

  @keyframes marquee {
    0% {
      transform: translateX(0);
    }
    100% {
      transform: translateX(-50%);
    }
  }

  .marquee-content {
    display: flex;
    align-items: center;
    gap: var(--space-lg);
    padding-right: var(--space-3xl);
    font-size: var(--text-sm);
    white-space: nowrap;
  }

  .now-playing {
    opacity: 0.6;
  }

  .player-title {
    font-weight: 500;
  }

  .player-time {
    opacity: 0.6;
    font-variant-numeric: tabular-nums;
  }

  /* Progress bar */
  .player-progress-wrap {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: rgba(255, 255, 255, 0.2);
    cursor: pointer;
  }

  .player-progress-bar {
    height: 100%;
    width: 100%;
  }

  .player-progress-fill {
    height: 100%;
    width: 0%;
    background: var(--color-blue);
    transition: width 0.1s linear;
  }

  @media (max-width: 640px) {
    .player-prev,
    .player-next {
      display: none;
    }

    .marquee-content {
      gap: var(--space-md);
      padding-right: var(--space-2xl);
    }
  }
</style>

<script>
  interface Mix {
    id: string;
    title: string;
    description: string | null;
    audio_url: string;
    cover_image_url: string | null;
    duration_seconds: number | null;
  }

  interface PlayerState {
    currentMixId: string | null;
    currentTime: number;
    isPlaying: boolean;
  }

  declare global {
    interface Window {
      __playerListenersAdded?: boolean;
      __playerState?: {
        mixes: Mix[];
        currentIndex: number;
      };
    }
  }

  const STORAGE_KEY = 'verbsPlayerState';

  // Shared player state
  function getPlayerState() {
    if (!window.__playerState) {
      const playerEl = document.getElementById('persistentPlayer');
      const mixes: Mix[] = playerEl ? JSON.parse(playerEl.dataset.mixes || '[]') : [];
      window.__playerState = { mixes, currentIndex: 0 };
    }
    return window.__playerState;
  }

  function formatTime(seconds: number): string {
    if (!seconds || !isFinite(seconds)) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  function saveState() {
    const audio = document.getElementById('globalAudio') as HTMLAudioElement;
    const { mixes, currentIndex } = getPlayerState();
    if (!audio || mixes.length === 0) return;

    const state: PlayerState = {
      currentMixId: mixes[currentIndex]?.id || null,
      currentTime: audio.currentTime || 0,
      isPlaying: !audio.paused
    };
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }

  function loadState(): PlayerState | null {
    const saved = sessionStorage.getItem(STORAGE_KEY);
    return saved ? JSON.parse(saved) : null;
  }

  function updateUI() {
    const playerEl = document.getElementById('persistentPlayer');
    const audio = document.getElementById('globalAudio') as HTMLAudioElement;
    if (!playerEl || !audio) return;

    const isPlaying = !audio.paused;
    playerEl.classList.toggle('playing', isPlaying);
  }

  function updateProgress() {
    const playerEl = document.getElementById('persistentPlayer');
    const audio = document.getElementById('globalAudio') as HTMLAudioElement;
    if (!playerEl || !audio) return;

    const timeEls = playerEl.querySelectorAll('.player-time');
    const progressFill = playerEl.querySelector('.player-progress-fill') as HTMLElement;

    const current = formatTime(audio.currentTime);
    const duration = formatTime(audio.duration);
    const percent = (audio.currentTime / audio.duration) * 100 || 0;

    timeEls.forEach(el => {
      el.textContent = `${current} / ${duration}`;
    });

    if (progressFill) {
      progressFill.style.width = `${percent}%`;
    }
  }

  function updateTitle(title: string) {
    const playerEl = document.getElementById('persistentPlayer');
    if (!playerEl) return;

    const titleEls = playerEl.querySelectorAll('.player-title');
    titleEls.forEach(el => {
      el.textContent = title;
    });
  }

  function selectMix(index: number, autoPlay = false) {
    const audio = document.getElementById('globalAudio') as HTMLAudioElement;
    const state = getPlayerState();
    const { mixes } = state;

    if (index < 0 || index >= mixes.length || !audio) return;

    const mix = mixes[index];
    state.currentIndex = index;

    updateTitle(mix.title);

    if (audio.src !== mix.audio_url) {
      audio.src = mix.audio_url;
    }

    if (autoPlay) {
      audio.play();
    }

    updateUI();
    saveState();
  }

  function togglePlay() {
    const audio = document.getElementById('globalAudio') as HTMLAudioElement;
    const { mixes, currentIndex } = getPlayerState();
    if (!audio || mixes.length === 0) return;

    if (!audio.src) {
      audio.src = mixes[currentIndex].audio_url;
    }

    if (audio.paused) {
      audio.play();
    } else {
      audio.pause();
    }
    updateUI();
    saveState();
  }

  function playNext() {
    const { mixes, currentIndex } = getPlayerState();
    const next = (currentIndex + 1) % mixes.length;
    selectMix(next, true);
  }

  function playPrev() {
    const { mixes, currentIndex } = getPlayerState();
    const prev = currentIndex <= 0 ? mixes.length - 1 : currentIndex - 1;
    selectMix(prev, true);
  }

  function seekTo(percent: number) {
    const audio = document.getElementById('globalAudio') as HTMLAudioElement;
    if (audio?.duration) {
      audio.currentTime = (percent / 100) * audio.duration;
      saveState();
    }
  }

  // Event delegation for player controls
  function handlePlayerClick(e: Event) {
    const target = e.target as HTMLElement;

    if (target.closest('.player-play')) {
      togglePlay();
      return;
    }

    if (target.closest('.player-prev')) {
      playPrev();
      return;
    }

    if (target.closest('.player-next')) {
      playNext();
      return;
    }

    const progressWrap = target.closest('.player-progress-wrap') as HTMLElement;
    if (progressWrap) {
      const rect = progressWrap.getBoundingClientRect();
      const percent = (((e as MouseEvent).clientX - rect.left) / rect.width) * 100;
      seekTo(percent);
      return;
    }
  }

  // Initialize player state and restore from session
  function initPlayerState() {
    const playerEl = document.getElementById('persistentPlayer');
    if (!playerEl) return;

    // Add body padding for the player (44px height)
    document.body.style.paddingTop = '44px';

    // Reset state with current mixes data
    const mixes: Mix[] = JSON.parse(playerEl.dataset.mixes || '[]');
    window.__playerState = { mixes, currentIndex: 0 };

    if (mixes.length === 0) return;

    // Restore state from session
    const savedState = loadState();
    if (savedState?.currentMixId) {
      const index = mixes.findIndex(m => m.id === savedState.currentMixId);
      if (index >= 0) {
        window.__playerState.currentIndex = index;
        updateTitle(mixes[index].title);

        const audio = document.getElementById('globalAudio') as HTMLAudioElement;
        if (audio && (savedState.isPlaying || savedState.currentTime > 0)) {
          audio.src = mixes[index].audio_url;
          if (savedState.currentTime > 0) {
            audio.currentTime = savedState.currentTime;
          }
          if (savedState.isPlaying) {
            audio.play().catch(() => {});
          }
        }

        updateUI();
      }
    }
  }

  // Set up event listeners only once
  if (!window.__playerListenersAdded) {
    // Click delegation for controls
    document.addEventListener('click', handlePlayerClick);

    // Audio events - these need to be on the audio element
    const audio = document.getElementById('globalAudio') as HTMLAudioElement;
    if (audio) {
      audio.addEventListener('timeupdate', updateProgress);
      audio.addEventListener('play', () => { updateUI(); saveState(); });
      audio.addEventListener('pause', () => { updateUI(); saveState(); });
      audio.addEventListener('ended', playNext);
    }

    // View Transitions state persistence
    document.addEventListener('astro:before-swap', saveState);
    document.addEventListener('astro:page-load', initPlayerState);

    window.__playerListenersAdded = true;
  }

  // Initialize on first load
  initPlayerState();
</script>
