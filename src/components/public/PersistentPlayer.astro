---
import type { Mix } from '../../lib/supabase';

interface Props {
  mixes: Mix[];
}

const { mixes } = Astro.props;
const firstMix = mixes[0];
---

{mixes.length > 0 && (
  <div class="persistent-player" id="persistentPlayer" data-mixes={JSON.stringify(mixes)}>
    <audio id="globalAudio" transition:persist="audio"></audio>

    <div class="player-bar">
      <div class="player-controls">
        <button class="player-btn player-prev" aria-label="Previous">Prev</button>
        <button class="player-btn player-play" aria-label="Play">
          <span class="play-text">Play</span>
          <span class="pause-text">Pause</span>
        </button>
        <button class="player-btn player-next" aria-label="Next">Next</button>
      </div>

      <div class="player-marquee">
        <div class="marquee-track">
          <span class="marquee-content">
            <span class="now-playing">Now playing:</span>
            <span class="player-title">{firstMix.title}</span>
            <span class="player-time">0:00</span>
          </span>
          <span class="marquee-content" aria-hidden="true">
            <span class="now-playing">Now playing:</span>
            <span class="player-title">{firstMix.title}</span>
            <span class="player-time">0:00</span>
          </span>
        </div>
      </div>

      <div class="player-progress-wrap">
        <div class="player-progress-bar">
          <div class="player-progress-fill"></div>
        </div>
      </div>
    </div>
  </div>
)}

<style>
  .persistent-player {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    background: var(--color-fg);
    color: var(--color-bg);
  }

  .player-bar {
    display: flex;
    align-items: center;
    height: 44px;
    padding: 0 var(--space-md);
    gap: var(--space-lg);
  }

  .player-controls {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    flex-shrink: 0;
  }

  .player-btn {
    background: transparent;
    border: 1px solid currentColor;
    color: inherit;
    padding: var(--space-xs) var(--space-sm);
    font-size: var(--text-xs);
    cursor: pointer;
    transition: background 0.15s, color 0.15s;
    white-space: nowrap;
  }

  .player-btn:hover {
    background: var(--color-bg);
    color: var(--color-fg);
  }

  .player-play {
    background: var(--color-blue);
    border-color: var(--color-blue);
  }

  .player-play:hover {
    background: transparent;
    color: var(--color-blue);
  }

  .player-play .pause-text {
    display: none;
  }

  .persistent-player.playing .player-play .play-text {
    display: none;
  }

  .persistent-player.playing .player-play .pause-text {
    display: inline;
  }

  /* Marquee container */
  .player-marquee {
    flex: 1;
    overflow: hidden;
    mask-image: linear-gradient(to right, transparent, black 5%, black 95%, transparent);
    -webkit-mask-image: linear-gradient(to right, transparent, black 5%, black 95%, transparent);
  }

  .marquee-track {
    display: flex;
    width: max-content;
    animation: marquee 20s linear infinite;
    animation-play-state: paused;
  }

  .persistent-player.playing .marquee-track {
    animation-play-state: running;
  }

  @keyframes marquee {
    0% {
      transform: translateX(0);
    }
    100% {
      transform: translateX(-50%);
    }
  }

  .marquee-content {
    display: flex;
    align-items: center;
    gap: var(--space-lg);
    padding-right: var(--space-3xl);
    font-size: var(--text-sm);
    white-space: nowrap;
  }

  .now-playing {
    opacity: 0.6;
  }

  .player-title {
    font-weight: 500;
  }

  .player-time {
    opacity: 0.6;
    font-variant-numeric: tabular-nums;
  }

  /* Progress bar */
  .player-progress-wrap {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: rgba(255, 255, 255, 0.2);
    cursor: pointer;
  }

  .player-progress-bar {
    height: 100%;
    width: 100%;
  }

  .player-progress-fill {
    height: 100%;
    width: 0%;
    background: var(--color-blue);
    transition: width 0.1s linear;
  }

  @media (max-width: 640px) {
    .player-prev,
    .player-next {
      display: none;
    }

    .marquee-content {
      gap: var(--space-md);
      padding-right: var(--space-2xl);
    }
  }
</style>

<script>
  interface Mix {
    id: string;
    title: string;
    description: string | null;
    audio_url: string;
    cover_image_url: string | null;
    duration_seconds: number | null;
  }

  interface PlayerState {
    currentMixId: string | null;
    currentTime: number;
    isPlaying: boolean;
  }

  const STORAGE_KEY = 'verbsPlayerState';

  function initPlayer() {
    const playerEl = document.getElementById('persistentPlayer');
    if (!playerEl) return;

    const audio = document.getElementById('globalAudio') as HTMLAudioElement;
    const mixes: Mix[] = JSON.parse(playerEl.dataset.mixes || '[]');

    if (mixes.length === 0) return;

    const titleEls = playerEl.querySelectorAll('.player-title');
    const timeEls = playerEl.querySelectorAll('.player-time');
    const progressFill = playerEl.querySelector('.player-progress-fill') as HTMLElement;
    const progressWrap = playerEl.querySelector('.player-progress-wrap') as HTMLElement;
    const playBtn = playerEl.querySelector('.player-play')!;
    const prevBtn = playerEl.querySelector('.player-prev')!;
    const nextBtn = playerEl.querySelector('.player-next')!;

    let currentIndex = 0;

    // Add body padding for the player (44px height)
    document.body.style.paddingTop = '44px';

    function formatTime(seconds: number): string {
      if (!seconds || !isFinite(seconds)) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    function saveState() {
      const state: PlayerState = {
        currentMixId: mixes[currentIndex].id,
        currentTime: audio.currentTime || 0,
        isPlaying: !audio.paused
      };
      sessionStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    function loadState(): PlayerState | null {
      const saved = sessionStorage.getItem(STORAGE_KEY);
      return saved ? JSON.parse(saved) : null;
    }

    function updateUI() {
      const isPlaying = !audio.paused;
      playerEl.classList.toggle('playing', isPlaying);
    }

    function updateProgress() {
      const current = formatTime(audio.currentTime);
      const duration = formatTime(audio.duration);
      const percent = (audio.currentTime / audio.duration) * 100 || 0;

      // Update all time elements in the marquee
      timeEls.forEach(el => {
        el.textContent = `${current} / ${duration}`;
      });

      // Update progress bar
      if (progressFill) {
        progressFill.style.width = `${percent}%`;
      }
    }

    function updateTitle(title: string) {
      titleEls.forEach(el => {
        el.textContent = title;
      });
    }

    function selectMix(index: number, autoPlay = false) {
      if (index < 0 || index >= mixes.length) return;

      const mix = mixes[index];
      currentIndex = index;

      updateTitle(mix.title);

      if (audio.src !== mix.audio_url) {
        audio.src = mix.audio_url;
      }

      if (autoPlay) {
        audio.play();
      }

      updateUI();
      saveState();
    }

    function togglePlay() {
      if (!audio.src) {
        audio.src = mixes[currentIndex].audio_url;
      }

      if (audio.paused) {
        audio.play();
      } else {
        audio.pause();
      }
      updateUI();
      saveState();
    }

    function playNext() {
      const next = (currentIndex + 1) % mixes.length;
      selectMix(next, true);
    }

    function playPrev() {
      const prev = currentIndex <= 0 ? mixes.length - 1 : currentIndex - 1;
      selectMix(prev, true);
    }

    function seekTo(percent: number) {
      if (audio.duration) {
        audio.currentTime = (percent / 100) * audio.duration;
        saveState();
      }
    }

    // Event listeners
    playBtn.addEventListener('click', togglePlay);
    prevBtn.addEventListener('click', playPrev);
    nextBtn.addEventListener('click', playNext);

    // Click on progress bar to seek
    progressWrap?.addEventListener('click', (e) => {
      const rect = progressWrap.getBoundingClientRect();
      const percent = ((e.clientX - rect.left) / rect.width) * 100;
      seekTo(percent);
    });

    // Audio events
    audio.addEventListener('timeupdate', updateProgress);
    audio.addEventListener('play', () => { updateUI(); saveState(); });
    audio.addEventListener('pause', () => { updateUI(); saveState(); });
    audio.addEventListener('ended', playNext);

    // View Transitions state persistence
    document.addEventListener('astro:before-swap', saveState);
    document.addEventListener('astro:after-swap', () => {
      setTimeout(() => initPlayer(), 0);
    });

    // Restore state on load
    const savedState = loadState();
    if (savedState?.currentMixId) {
      const index = mixes.findIndex(m => m.id === savedState.currentMixId);
      if (index >= 0) {
        currentIndex = index;
        updateTitle(mixes[index].title);

        if (savedState.isPlaying || savedState.currentTime > 0) {
          audio.src = mixes[index].audio_url;
          if (savedState.currentTime > 0) {
            audio.currentTime = savedState.currentTime;
          }
          if (savedState.isPlaying) {
            audio.play().catch(() => {});
          }
        }

        updateUI();
      }
    }
  }

  initPlayer();
</script>
