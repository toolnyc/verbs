---
import type { Event, TicketTier } from '../../lib/supabase';

interface Props {
  events: Event[];
  isAuthenticated?: boolean;
  featuredEventId?: string | null;
  nextEventDate?: string | null;
  featuredTier?: TicketTier | null;
}

const { events, isAuthenticated = false, featuredEventId = null, nextEventDate = null, featuredTier = null } = Astro.props;

// Format price for featured tier button
const featuredPrice = featuredTier ? new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD',
}).format(featuredTier.price) : null;

// Calculate available stock for featured tier
const featuredAvailable = featuredTier && featuredTier.max_stock !== null
  ? featuredTier.max_stock - featuredTier.sold_count
  : null;
---

<div class="verb-grid" data-next-event={nextEventDate || ''}>
  {events.map(event => {
    const isPublished = event.status === 'published';
    const isDraft = event.status === 'draft';
    const isFeatured = event.id === featuredEventId;
    // Published events are always clickable; drafts only when authenticated
    const isClickable = isPublished || (isDraft && isAuthenticated);

    return isClickable ? (
      <div class={`verb-item-wrapper ${isFeatured ? 'featured' : ''}`}>
        <a
          href={`/events/${event.id}`}
          class={`verb-item clickable ${isDraft ? 'draft' : ''} ${isFeatured ? 'featured' : ''}`}
          data-hover-color={event.hover_color || ''}
        >
          <div class="hover-bg"></div>
          <span class="verb-title">
            {event.title}
            {isFeatured && <span class="featured-countdown" id="featured-countdown"> in --</span>}
          </span>
          {isDraft && <span class="draft-badge">Draft</span>}
          {(event.flyer_url || event.image_url) && (
            <div class="flyer-preview">
              <img src={event.flyer_url || event.image_url} alt={event.title} />
            </div>
          )}
        </a>
        {isFeatured && featuredTier && (
          <button
            class="buy-btn featured-buy-btn"
            data-event-id={event.id}
            data-tier-id={featuredTier.id}
            data-tier-name={featuredTier.name}
            data-price={featuredTier.price}
            data-available={featuredAvailable}
          >
            Buy {featuredPrice}
          </button>
        )}
      </div>
    ) : (
      <div class={`verb-item-wrapper ${isFeatured ? 'featured' : ''}`}>
        <div class={`verb-item future ${isFeatured ? 'featured' : ''}`}>
          <span class="verb-title">
            {event.title}
            {isFeatured && <span class="featured-countdown" id="featured-countdown"> in --</span>}
          </span>
          {(event.flyer_url || event.image_url) && (
            <div class="flyer-preview">
              <img src={event.flyer_url || event.image_url} alt={event.title} />
            </div>
          )}
        </div>
        {isFeatured && featuredTier && (
          <button
            class="buy-btn featured-buy-btn"
            data-event-id={event.id}
            data-tier-id={featuredTier.id}
            data-tier-name={featuredTier.name}
            data-price={featuredTier.price}
            data-available={featuredAvailable}
          >
            Buy {featuredPrice}
          </button>
        )}
      </div>
    );
  })}
</div>

<style>
  /* Wrapper for featured items with buy button */
  .verb-item-wrapper {
    display: contents;
  }

  .verb-item-wrapper.featured {
    display: flex;
  }

  .verb-item-wrapper.featured .verb-item {
    flex: 1;
  }

  .verb-item.draft {
    position: relative;
  }

  .verb-item.clickable {
    position: relative;
    overflow: hidden;
  }

  .hover-bg {
    position: absolute;
    inset: 0;
    background: var(--color-fg);
    transform: translateY(100%);
    z-index: 0;
    pointer-events: none;
  }

  .verb-item .verb-title {
    position: relative;
    z-index: 1;
  }

  .draft-badge {
    position: absolute;
    top: var(--space-sm);
    right: var(--space-sm);
    font-size: var(--text-xs);
    padding: var(--space-xs) var(--space-sm);
    background: var(--color-bg);
    border: 1px solid var(--color-fg);
    opacity: 0.8;
    z-index: 2;
  }

  /* Featured countdown indicator - inline with title */
  .featured-countdown {
    display: inline;
    font-size: var(--text-base);
    font-weight: 400;
    opacity: 0.6;
    font-variant-numeric: tabular-nums;
  }

  /* Featured buy button - right aligned, full height, prominent */
  .featured-buy-btn {
    align-self: stretch;
    display: flex;
    align-items: center;
    padding: 0 var(--space-3xl);
    font-size: var(--text-lg);
    font-weight: 700;
    white-space: nowrap;
    background: var(--color-green);
    border: none;
    color: var(--color-fg);
    cursor: pointer;
    transition: background 0.2s, color 0.2s;
  }

  .featured-buy-btn:hover {
    background: var(--color-fg);
    border-color: var(--color-fg);
    color: var(--color-bg);
  }

  /* Mobile: Stack title/countdown above buy button */
  @media (max-width: 768px) {
    .verb-item-wrapper.featured {
      flex-direction: column;
    }

    .featured-buy-btn {
      width: 100%;
      justify-content: center;
      padding: var(--space-lg);
    }
  }
</style>

<script>
  import gsap from 'gsap';
  import { createHoverPreview } from '../../lib/animations';

  // Store cleanup functions for re-initialization
  const cleanupFunctions: (() => void)[] = [];

  function initVerbGridAnimations() {
    // Clean up previous animations
    cleanupFunctions.forEach(cleanup => cleanup());
    cleanupFunctions.length = 0;

    // Initialize hover previews and animated backgrounds for verb items
    const verbItems = document.querySelectorAll('.verb-item');

    verbItems.forEach(item => {
      const preview = item.querySelector('.flyer-preview') as HTMLElement;
      if (preview) {
        const cleanup = createHoverPreview(item as HTMLElement, preview);
        cleanupFunctions.push(cleanup);
      }

      // Only add hover animation to clickable items
      if (!item.classList.contains('clickable')) return;

      const hoverBg = item.querySelector('.hover-bg') as HTMLElement;
      const title = item.querySelector('.verb-title') as HTMLElement;
      if (!hoverBg || !title) return;

      // Get custom hover color if set
      const customColor = (item as HTMLElement).dataset.hoverColor;
      const bgColor = customColor || 'var(--color-fg)';

      // Reset any existing transforms and apply custom color
      gsap.set(hoverBg, { y: '100%', skewY: 0, backgroundColor: bgColor });
      gsap.set(title, { clearProps: 'color' });

      // GSAP hover animation
      const tl = gsap.timeline({ paused: true });

      // Animate background sliding up with a slight skew for diagonal effect
      tl.to(hoverBg, {
        y: 0,
        skewY: -2,
        duration: 0.4,
        ease: 'power3.out',
      })
      .to(hoverBg, {
        skewY: 0,
        duration: 0.2,
        ease: 'power2.out',
      }, '-=0.1')
      .to(title, {
        color: 'var(--color-bg)',
        duration: 0.3,
        ease: 'power2.out',
      }, 0.1);

      const onEnter = () => tl.play();
      const onLeave = () => tl.reverse();

      item.addEventListener('mouseenter', onEnter);
      item.addEventListener('mouseleave', onLeave);

      // Store cleanup function
      cleanupFunctions.push(() => {
        tl.kill();
        item.removeEventListener('mouseenter', onEnter);
        item.removeEventListener('mouseleave', onLeave);
      });
    });
  }

  // Featured countdown logic
  declare global {
    interface Window {
      _verbGridCountdownInterval?: number;
    }
  }

  function updateFeaturedCountdown() {
    const grid = document.querySelector('.verb-grid') as HTMLElement;
    const nextEventDate = grid?.dataset.nextEvent;
    const countdownEl = document.getElementById('featured-countdown');

    if (!countdownEl || !nextEventDate) {
      if (countdownEl) countdownEl.textContent = '';
      return;
    }

    const now = new Date();
    const eventDate = new Date(nextEventDate);
    const diff = eventDate.getTime() - now.getTime();

    if (isNaN(diff)) {
      countdownEl.textContent = '';
      return;
    }

    if (diff <= 0) {
      countdownEl.textContent = ' now';
      return;
    }

    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));

    let countdownText = '';
    if (days > 0) {
      countdownText = ` in ${days}d ${hours}h ${minutes}m`;
    } else if (hours > 0) {
      countdownText = ` in ${hours}h ${minutes}m`;
    } else {
      countdownText = ` in ${minutes}m`;
    }

    countdownEl.textContent = countdownText;
  }

  function initFeaturedCountdown() {
    if (window._verbGridCountdownInterval) {
      clearInterval(window._verbGridCountdownInterval);
    }
    updateFeaturedCountdown();
    window._verbGridCountdownInterval = window.setInterval(updateFeaturedCountdown, 60000); // Update every minute
  }

  // Initialize on first load
  initVerbGridAnimations();
  initFeaturedCountdown();

  // Re-initialize after Astro view transitions
  document.addEventListener('astro:page-load', () => {
    initVerbGridAnimations();
    initFeaturedCountdown();
  });
</script>
